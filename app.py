from flask import Flask,render_template,render_template_string,request
import requests
import json
import textwrap 
import math
API_KEY = "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"

app=Flask(__name__,template_folder='template', static_folder='static')

user_input_global = None 
detailresponse = None
formulas_global = None
Output = None
htmll_final = None
flask_final = None

@app.route('/')
def index():
    return render_template('base.html')

@app.route('/ask', methods=['POST'])
def ask():
    global user_input_global
    global detailresponse
    global formulas_global
    global htmll_final
    user_input_global = request.form.get('user_input')  # Get the value of the input field
    print("User Input:", user_input_global)

    detailresp = requests.post(
        url="https://openrouter.ai/api/v1/chat/completions",
        headers={
            "Authorization": f"Bearer {API_KEY}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost",  # optional
            "X-Title": "DeepSeekTerminalApp"     # optional
        },
        data=json.dumps({
            "model": "deepseek/deepseek-chat-v3-0324:free",
            "messages": [
                {
                    "role": "user",
                    "content": f"write a detail respone in html formate without script(javascript) and form or ask value from user . of the{user_input_global}and return only the html code without any other word and "
                }
            ],
            "max_tokens": 1000
        })
    )
    print("frist api request done")
    data1 = detailresp.json()
    if "choices" in data1 and len(data1["choices"]) > 0:
        detailresponse = data1["choices"][0]["message"]["content"]
        print(f"ðŸ¤–: {detailresponse}")
    else:
        print("Error: 'choices' key not found or empty in the response")

    formulaset=f"write in html formate without javascripts and form or ask value from user to Create a one-line equation and one equation not multiple from \"{detailresponse}\". Include only the equation, return only the html text code without any script(javascript) code and explanation or example calculation, and ensure it is converted into a single-line format."
    print ("second code request done")
    formulas = requests.post(
        url="https://openrouter.ai/api/v1/chat/completions",
        headers={
            "Authorization": f"Bearer {API_KEY}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost",  # optional
            "X-Title": "DeepSeekTerminalApp"     # optional
        },
        data=json.dumps({
            "model": "deepseek/deepseek-chat-v3-0324:free",
            "messages": [
                {
                    "role": "user",
                    "content": formulaset
                }
            ],
            "max_tokens": 1000
        })
    )
    data2 = formulas.json()
    if "choices" in data2 and len(data2["choices"]) > 0:
        formulas_global = data2["choices"][0]["message"]["content"]
        print(f"ðŸ¤–: {formulas_global}")
    else:
        print("Error: 'choices' key not found or empty in the response")
    print("third code request done")
    htmlcode = f"""Take the following formula and convert it into an HTML form that asks for the required input values:

    Formula: {formulas_global}

    Create a form with input fields for each variable in the formula, a submit button to calculate the result, and a reset button.

    Use this exact template structure and don't modify the form action line:

    {{% extends 'base.html' %}}
    {{% block title %}} Formula Calculator {{% endblock %}}
    {{% block content %}}

    <form action=\"{{{{url_for('call')}}}}\" method=[\"POST\",\"GET\"]>
    <!-- Form content will be dynamically generated by AI based on the formula -->
    </form>

    {{% endblock %}}
    

    except code no explanintion is needed or any other word. Just return the code only.
    """

    htmlll = requests.post(
        url="https://openrouter.ai/api/v1/chat/completions",
        headers={
            "Authorization": f"Bearer {API_KEY}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost",  # optional
            "X-Title": "DeepSeekTerminalApp"     # optional
        },
        data=json.dumps({
            "model": "deepseek/deepseek-chat-v3-0324:free",
            "messages": [
                {
                    "role": "user",
                    "content": htmlcode
                }
            ],
            "max_tokens": 1000
        })
    )
    data3 = htmlll.json()
    if "choices" in data3 and len(data3["choices"]) > 0:
        htmll_final = data3["choices"][0]["message"]["content"]
        print(f"ðŸ¤–: {htmll_final}")
        htmll_final = htmll_final.replace("```html", "").replace("```", "")
    else:
        print("Error: 'choices' key not found or empty in the response")
        htmll_final = None  # Ensure htmll_final is explicitly set to None

    # Check if htmll_final is valid before proceeding
    if htmll_final is None:
        print("Error: htmll_final is None")
        return "Error: Failed to generate HTML code", 500

    test()
    return render_template_string(htmll_final)

def test():
    global htmll_final
    global formulas_global
    global flask_final
    falskprompt=f"""Generate only the Python code to be inserted inside this Flask function template based on the given equation and HTML form inputs. Do not include any explanations, comments, or output except for the generated Python code inside the allocated section.

    Template:

    @app.route('/call', methods=['POST'])
    def call():
    â€ƒâ€ƒglobal detailresponse
    â€ƒâ€ƒglobal formulas_global
    â€ƒâ€ƒglobal Output

    â€ƒâ€ƒ<-- generated code here -->

    â€ƒâ€ƒ# Save the final output to the Output variable and dont assign any for detailresponse,formulas_global

    Given equation: '{formulas_global}'
    Given HTML form: '{htmll_final}'

    Only return the Python code to be inserted at '<-- generated code here -->'. Do not add any additional words or explanations.
    """
    flaskout = requests.post(
        url="https://openrouter.ai/api/v1/chat/completions",
        headers={
            "Authorization": f"Bearer {API_KEY}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost",  # optional
            "X-Title": "DeepSeekTerminalApp"     # optional
        },
        data=json.dumps({
            "model": "openrouter/optimus-alpha",
            "messages": [
                {
                    "role": "user",
                    "content": falskprompt
                }
            ],
            "max_tokens": 1000
        })
    )
    data4 = flaskout.json()
    if "choices" in data4 and len(data4["choices"]) > 0:
        flask_final = data4["choices"][0]["message"]["content"]
        print(f"ðŸ¤–:")
    else:
        print("Error: 'choices' key not found or empty in the response")
    flask_final = flask_final.replace("```python", "")  # Remove the "```html" string
    flask_final = flask_final.replace("```", "")
    print(flask_final)
    

@app.route('/call', methods=['POST', 'GET'])
def call():
    global detailresponse
    global formulas_global
    global Output
    global flask_final

    # Ensure flask_final is not None or invalid
    if flask_final is None:
        print("Error: flask_final is None")
        return "Error: flask_final is None", 500

    # Collect user inputs based on the request method
    if request.method == 'POST':
        user_inputs = request.form.to_dict()  # Collect inputs from form data
    elif request.method == 'GET':
        user_inputs = request.args.to_dict()  # Collect inputs from query parameters
    else:
        user_inputs = {}

    print(f"Collected user inputs: {user_inputs}")

    # Retry loop for error handling
    max_retries = 1  # Only one retry before asking the API to compute the result
    for attempt in range(max_retries):
        # Check if 'global Output' is in flask_final, if not, add it
        if "global Output" not in flask_final:
            flask_final = f"global Output and error\n{flask_final}"

        # Normalize indentation in flask_final
        try:
            flask_final = textwrap.dedent(flask_final)
        except Exception as e:
            print(f"Error normalizing flask_final indentation: {e}")
            return f"Error normalizing flask_final indentation: {e}", 500

        # Debug the value of flask_final
        print(f"Attempt {attempt + 1}: Executing flask_final:")
        print(flask_final)

        # Dynamically execute the generated code
        try:
            exec(flask_final, globals())  # Execute in the global scope
            if Output is None:
                raise ValueError("Output is None after execution")
            break  # Exit the loop if execution is successful
        except Exception as e:
            print(f"executing flask_final: ")

            # Ask the API to compute the result using the inputs and the equation
            compute_prompt = f"""
            Compute the result of the following equation using the provided inputs:

            Equation: {formulas_global}
            Inputs: {user_inputs}

            Return only the computed result as a number or string with Unit . Do not include any explanations or additional text.
            """
            compute_response = requests.post(
                url="https://openrouter.ai/api/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {API_KEY}",
                    "Content-Type": "application/json",
                },
                data=json.dumps({
                    "model": "openrouter/optimus-alpha",
                    "messages": [
                        {
                            "role": "user",
                            "content": compute_prompt
                        }
                    ],
                    "max_tokens": 100
                })
            )
            compute_data = compute_response.json()
            if "choices" in compute_data and len(compute_data["choices"]) > 0:
                Output = compute_data["choices"][0]["message"]["content"]
                print(f"final-computed Output: {Output}")
                break  # Exit the loop after assigning the API-computed Output
            else:
                print("Error: Failed to compute the result from the API")
                return "Error: Failed to compute the result from the API", 500

    # Debug the value of Output after execution
    print("Value of Output after executing flask_final:", Output)

    # Save the final output to the Output variable
    return render_template('output.html', formulas_global=formulas_global, Output=Output, detailresponse=detailresponse)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000, debug=True)